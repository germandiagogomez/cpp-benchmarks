* Purpose

This is a set of benchmarks in C++ that tries
to compare "raw implementation" vs "library-based"
implementations of some algorithms and compare their speeds.

So for every benchmark two implementations are included:
a raw one and a library-based, idiomatic one.


I am particularly interested in measuring the abstraction
penalty incurred by the use of a library vs plain approaches
*when compiling programs with optimization*, since one
of the goals of C++ is to the zero-overhead principle.


My first experiment makes use of [[https://github.com/ericniebler/range-v3][Eric Niebler's ranges library]].
There is a standard C++ proposal for inclusion based on this work.

* Benchmarks

** Hardware information

I am using a =2,4 GHz Intel Core i5 4 GB 1600 MHz DDR3= with graphics
card =Intel Iris 1536 MB=. My OS is =OSX Yosemite 10.10.1=.


The versions of the compilers used for the benchmarks in my computer are:

   - g++-5 (Homebrew gcc5 5.2.0) 5.2.0.
   - Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn)
     Target: x86_64-apple-darwin14.0.0
     Thread model: posix.

** Results

- Sequential sieve algorithm.
   - [[./benchmarks/01-sieve/raw_sieve.cpp][Raw sieve]].
   - [[./benchmarks/01-sieve/ranges_sieve.cpp][Ranges Sieve]].

#+CAPTION: Sieve benchmark result.
#+NAME: fig:sieve-bench
[[./benchmarks/01-sieve/plot-out/benchmark.png]]

* Compile and run the benchmarks

If you want to run the benchmark yourself in your computer (Linux or Mac).

You will need gnu plot installed in your computer for the plot output.
If you just want the test results, you can use the =configure= script
included in =benchmarks/01-sieve/configure= and run =make=.



#+BEGIN_src sh
git clone https://github.com/germandiagogomez/the-cpp-abstraction-penalty.git
git submodule init
git submodule update
cd benchmarks/01-sieve
./configure
cd build
make COMPILERS=clang++ g++ plot
#+END_src

This will output a plot with the median of 5 executions
for each binary with each compiler and will group by compiler,
so that a comparison of raw vs library-based solution can be seen.


*WARNING*: I just tested the plot output using the setup above.
Modifications should be easy to further generalize this infraestructure.
I plan to do it.
